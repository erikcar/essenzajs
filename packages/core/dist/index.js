!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.webground=e():n.webground=e()}(self,(()=>(()=>{"use strict";var __webpack_modules__={"./src/Apix.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Apix: () => (/* binding */ Apix)\n/* harmony export */ });\n/* harmony import */ var _channels_FetchChannel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./channels/FetchChannel */ "./src/channels/FetchChannel.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\n\n//import postgreSql from \'./interpreters/ISql\';\n\n//Usa servizio ajax \nconsole.log("****APIX****");\n//Controllo se chiamata ad operazione è già in corso o in coda\n//(per le chiamate da eseguire sync potrei anche dare possibilità di dare un riferimento dopo la quale essere eseguita)\n//se non trova callID lo mette per ultimo oppure esegue in modo async\n\nvar call_queue = [];\n//in questo caso è come se fosse un singleton\nvar apix = function (channel, ecatch, retry) {\n  this.channel = channel || new _channels_FetchChannel__WEBPACK_IMPORTED_MODULE_0__.fetchChannel();\n  this.parser = null; //postgreSql;\n  this.ecatch = ecatch;\n  this.dataOp = "api/jdata";\n  this.queryOp = "api/jquery";\n  this.apiUrl = "api/";\n  this.method = "post";\n  if (typeof retry === \'undefined\') {\n    retry = new callRetry(3, 500);\n  }\n  this.retry = retry;\n  return this;\n};\nfunction callRetry(num, wait) {\n  this.attempts = num;\n  if (Array.isArray(wait)) {\n    this.wait = wait;\n  } else {\n    this.wait = Array(num).fill(wait);\n  }\n  this.count = 0;\n  this.onApply = null;\n  this.canApply = er => this.count < this.attempts; // && er.type !== "RESPONSE";\n  this.apply = async er => {\n    await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.sleep)(wait[++this.count]);\n    if (this.onApply) {\n      this.onApply(er);\n    }\n  };\n  this.reset = () => this.count = 0;\n}\n\n//TODO: Gestire [messaggi utente, progress, assicurarsi di liberare queue, come gestire promise di LOCK (await?)]\napix.fn = apix.prototype = {\n  call: function (op, data, opt) {\n    console.log("APIX START CALL");\n    opt = opt || {};\n    opt.url = op;\n    opt.data = data;\n    console.log("APIX START CALL OPTION", opt);\n    this.formatOption(opt);\n\n    //SE è sigleton ed è già in esecuzione DISCARD => restitusco direttamente errore di  Promise.reject({type: \'\'});\n    // canExecute può essere [\'SINGLETON\', \'LOCK\', \'PARALLEL\'] ma PARALLEL implica che può fare la chiamata senza controlli quindi si lascia canExecute undefined\n    if (opt.mode && !CanExecute(op, opt)) {\n      if (opt.mode === \'SINGLETON\') {\n        return Promise.reject({\n          type: \'DISCARD\'\n        });\n      } else {\n        //LOCK case => put ACTION in queue\n        let callObj = {\n          id: op,\n          option: opt,\n          resolve: null,\n          reject: null\n        };\n        call_queue.push(callObj);\n        opt.lock = true;\n        return new Promise(function (resolve, reject) {\n          callObj.resolve = resolve;\n          callObj.reject = reject;\n        });\n      }\n    }\n\n    // SE DEVO METTERE IN CODA COSA RESTITUISCO? un promise che aspetta il suo turno ed eventualmente ha un meccanismo per eliminarsi da coda dopo un certo timeout\n    //Sarebbe ottimo uno scheduler simple and light\n    let instance = this;\n    opt.promise = new Promise(function (resolve, reject) {\n      instance.rawCall(opt, resolve, reject);\n    });\n    return opt.promise;\n  },\n  callMany: function () {},\n  syncCall: function () {},\n  // Serve sol per canExecute di client Action (che non prevedono chiamate remote o async)\n\n  option: function () {\n    return {\n      method: this.method,\n      channel: this.channel,\n      parser: this.parser,\n      dataOp: this.dataOp,\n      queryOp: this.queryOp\n    }; //, apiUrl: this.apiUrl\n  },\n\n  formatOption: function (opt) {\n    let defaultOption = this.option();\n    for (let key in defaultOption) {\n      if (!opt.hasOwnProperty(key)) {\n        opt[key] = defaultOption[key];\n      }\n    }\n    opt.attempt = opt.attempt || 3;\n    if (opt.apiUrl) opt.url = opt.apiUrl + opt.url;\n  },\n  canRetray: function (error, opt, resolve, reject) {\n    let retry = opt.retry || this.retry;\n    console.log(error, retry);\n    const data = error.response?.data;\n    if (error.type === "RESPONSE" && data && data.uidt === "ERROR") {\n      if (this.onManagedError) this.onManagedError(data);\n      //reject(error);\n      return false;\n    } else if (error.type !== "CALL" && retry && retry.canApply(error)) {\n      console.log("TENTATIVO: ", retry.count);\n      retry.apply(opt);\n      this.rawCall(opt, resolve, reject);\n      return true;\n    } else {\n      checkQueue(opt); //error.config);\n      if (this.onError) this.onError(error);\n      //reject(error);\n      return false;\n      //Log to server error.message?\n    }\n  },\n\n  rawCall: function (opt, resolve, reject) {\n    let channel = opt.channel;\n    let instance = this;\n    console.log("APIX RAW CALL: ", opt);\n    channel.send(opt).then(response => {\n      //GESTIRE ACTION ON RESULT - FACCIO PRIMA O DOPO resolve? ovvero faccio eventuale chiamata prima che venga gestita?\n      checkQueue(response.config);\n      response.config.promise = null; //Si può? delete? non viene comunque liberata da axios?\n      //Qui potrei fare gestione generale di MangaedError\n      const data = response.data;\n      if (data && data.hasOwnProperty("uidt") && data.uidt === "ERROR") {\n        if (instance.onManagedError) instance.onManagedError(data);\n        reject(data);\n      } else {\n        resolve({\n          response: response,\n          data: response.data,\n          args: response.config.args,\n          opt: response.config\n        });\n      }\n    }, error => !instance.canRetray(error, opt, resolve, reject) && reject(error)).catch(function (error) {\n      if (!instance.canRetray(error, opt, resolve, reject)) throw error;\n    });\n  }\n};\nconst Apix = new apix();\n//Potrei creare object o class Request con tutte le info per eseguire la call\n//Da esportare, esiste caso in cui stessa op viene chiamata\n/**\r\n *\r\n * @param {operation} op\r\n * @param {*Data to send} data\r\n * @param {*option of axios more args} opt\r\n */\n\n/*function progressWidth(evt) {\r\n  if (evt.lengthComputable) {\r\n    var percentComplete = evt.loaded / evt.total;\r\n    console.log(percentComplete);\r\n    $(".lbn-progress").css({\r\n      width: percentComplete * 100 + "%",\r\n    });\r\n  }\r\n}*/\n\nfunction CanExecute(id, config) {\n  console.log("PASSA CanExecute: ", id);\n  if (findCall(id) > -1 && (config.mode === \'SINGLETON\' || config.mode === \'LOCK\')) {\n    return false;\n  }\n  return true;\n}\n\n//be javascript in browser single thread would be safe index (not change) between findCall and remove\nfunction checkQueue(config) {\n  if (config.mode) {\n    let index = findCall(config.url);\n\n    //Attenzione se faccio chiamata ad id dopo che ho eliminato potrei eseguire insieme così\n    if (index > -1) {\n      if (config.mode === \'LOCK\') {\n        //DO el call esegue adesso chiamata AXIOS\n        let call = call_queue[index];\n        const opt = call.option;\n        Apix.call(opt.url, opt.data, opt).then(result => call.resolve(result)).catch(reason => call.reject(reason));\n      }\n      call_queue.splice(index, 1);\n    }\n  }\n}\nfunction findCall(id) {\n  return call_queue.findIndex(e => e.id = id);\n}\n\n//# sourceURL=webpack://webground/./src/Apix.js?')},"./src/binding.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Binder: () => (/* binding */ Binder),\n/* harmony export */   Shared: () => (/* binding */ Shared)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./src/core.js");\n\nfunction Shared(target, key) {\n  this.target = target;\n  this.key = key;\n  this.next = null;\n  this.format = [];\n}\nShared.prototype = {\n  bind(source) {\n    this.source = source;\n    this.format.forEach(f => f(source, this.target));\n    this.name && (this.target[this.name] = source);\n  },\n  listen(event, task) {\n    this.format.push(s => s.listen(event, task || this.target));\n    return this;\n  },\n  observe(event, obs) {\n    const task = obs ? obs.createTask() : new Task();\n    this.format.push(s => s.listen(event, task));\n    return task;\n  },\n  with(f) {\n    this.format.push(f);\n    return this;\n  },\n  as(name) {\n    this.name = name;\n    return this;\n  }\n};\nfunction Binder() {\n  this.map = new Map();\n}\nBinder.prototype = {\n  /**Per ora getsisco caso come se esiste un solo type attivo contemporaneamente */\n  share: function (type, target, key) {\n    const shared = new Shared(target, key);\n    if (this.map.has(type)) shared.next = this.map.get(type);\n    this.map.set(type, shared);\n    return shared;\n  },\n  bind: function (type, key) {\n    const source = new type();\n    let shared;\n    if (this.map.has(type)) {\n      shared = this.map.get(type);\n      while (shared) {\n        shared.key === key && shared.bind(source);\n        shared = shared.next;\n      }\n    }\n    return source;\n  }\n\n  /*find: function (type, path) {\r\n      let shared;\r\n      if (this.map.has(type)) {\r\n          shared = this.map.get(type);\r\n          while (shared) {\r\n              if (shared.path === path) {\r\n                  break;\r\n              }\r\n              shared = shared.next;\r\n          }\r\n      }\r\n      return shared;\r\n  },\r\n    addOrCreate: function (type, path, target) {\r\n      const node = new Node(target);\r\n      const shared = this.find(type, path);\r\n      return shared ? shared.instance : this.share(type, path).instance;\r\n      return node;\r\n  },\r\n    \r\n    firstOrDefault: function (type, path) {\r\n      const shared = this.first(type, path, false);\r\n      return shared ? shared.instance : new type();\r\n  },\r\n    firstOrCreate: function (type, path) {\r\n      const shared = this.first(type, path);\r\n      return shared ? shared.instance : this.share(type, path).instance;\r\n  },*/\n};\n\n/** Da aggiungere poi condition */\n/*export function Shared(type, path) {\r\n    this.instance = new type();\r\n    this.path = path;\r\n    this.next = null;\r\n    this.nodes = [];\r\n}\r\n\r\nShared.prototype = {\r\n    bind(source) {\r\n        this.nodes.forEach(n => n.bind(source));\r\n    }\r\n}*/\n\n//# sourceURL=webpack://webground/./src/binding.js?')},"./src/breakpoint.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BreakPointer: () => (/* binding */ BreakPointer)\n/* harmony export */ });\nconst BreakPoint = {\n  xs: 0,\n  sm: 2,\n  md: 4,\n  lg: 8,\n  xl: 16,\n  xxl: 32\n};\nfunction BreakPointer(breakpoints) {\n  this.count = 0;\n  this.breakpoints = breakpoints || [{\n    label: 'xs',\n    value: 576\n  }, {\n    label: 'sm',\n    value: 768\n  }, {\n    label: 'md',\n    value: 992\n  }, {\n    label: 'lg',\n    value: 1200\n  }, {\n    label: 'xl',\n    value: 1600\n  }, {\n    label: 'xxl',\n    value: 100000\n  }];\n  this.listening = false;\n  this.point = null;\n  this.index = 0;\n  this.lastw = 0;\n  this.state = null;\n  this.getState = function () {\n    if (!this.listening) this.sync();\n    return this.state;\n  };\n  this.init = function (breakpoints) {\n    this.points = [];\n    this.state = {};\n    for (let k = 0; k < breakpoints.length; k++) {\n      const p = breakpoints[k];\n      //BreakPoint[p.label] = k*2;\n      this.points.push(p.value);\n      this.state[p.label] = p;\n    }\n  };\n  this.sync = function () {\n    this.lastw = window.innerWidth || 0;\n    let i = 0;\n    while (this.lastw > this.points[i]) {\n      this.breakpoints[i].active = true;\n      i++;\n    }\n    this.point = this.breakpoints[i];\n    this.index = i;\n    console.log(\"SYNC-BP\", this.point, i, this.lastw);\n  };\n  this.register = function (size, listener) {\n    this.count++;\n    const bp = this.state[size];\n    if (!bp.observers) bp.observers = [];\n    bp.observers.push(listener);\n    if (!this.listening) {\n      window.addEventListener('resize', this.onresize.bind(this));\n      this.listening = true;\n      this.sync();\n    }\n  };\n  this.unregister = function (size, listener) {\n    const obs = this.state[size].observers;\n    for (let k = 0; k < obs.length; k++) {\n      if (obs[k] === listener) {\n        obs.splice(k, 1);\n        break;\n      }\n    }\n    this.count--;\n    if (this.count < 1) {\n      window.removeEventListener('resize', this.onresize);\n      this.listening = false;\n      //Non serve perche quando parte listening comunque faccio sync\n      const bp = this.breakpoints;\n      for (let k = 0; k < this.index; k++) {\n        bp[k].active = false;\n      }\n    }\n  };\n  this.onresize = function () {\n    const w = window.innerWidth;\n    console.log(w, this.lastw);\n    if (w > this.lastw) {\n      if (w > this.point.value) {\n        const bp = this.breakpoints;\n        this.point.active = true;\n        let obs = this.point.observers || [];\n        let i = ++this.index;\n        while (w > this.points[i]) {\n          bp[i].active = true;\n          if (bp[i].observers) obs = obs.concat(bp[i].observers);\n          i++;\n        }\n        this.point = bp[i];\n        this.index = i;\n        this.notify(obs);\n      }\n    } else if (w < this.points[this.index - 1]) {\n      const bp = this.breakpoints;\n      let i = this.index - 1;\n      let obs = [];\n      while (w < this.points[i]) {\n        bp[i].active = false;\n        if (bp[i].observers) obs = obs.concat(bp[i].observers);\n        i--;\n      }\n      i++;\n      this.point = bp[i];\n      this.index = i;\n      this.notify(obs);\n    }\n    this.lastw = w;\n  };\n  this.notify = function (obs) {\n    const s = {\n      ...this.state\n    };\n    console.log(\"BP-NOTIFY\", obs, s);\n    for (let k = 0; k < obs.length; k++) {\n      obs[k](s);\n    }\n  };\n  this.init(this.breakpoints);\n}\n\n//# sourceURL=webpack://webground/./src/breakpoint.js?")},"./src/channels/AxiosChannel.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   axiosChannel: () => (/* binding */ axiosChannel)\n/* harmony export */ });\n//const axios = require("axios");\n\n/**\r\n * Un channel deve restituire un promise con result o error. Il formato di result ed error sono quelli di axios,\r\n * quindi gli altri canali si devono adattare (adapter) a uesto formato.\r\n * @param {*} opt\r\n * @returns\r\n */\n\nfunction axiosChannel(baseUrl) {\n  this.baseUrl = baseUrl;\n  axios.defaults.headers.post["Content-Type"] = "application/x-www-form-urlencoded";\n  this.send = function (opt) {\n    console.log("AXIOS CHANNEL SEND: ", opt.url);\n    if (this.baseUrl) opt.baseUrl = this.baseUrl;\n    if (opt.method === "post" && opt.data && !opt.excludeParams) {\n      const params = new URLSearchParams();\n      for (let key in opt.data) {\n        params.append(key, opt.data[key]);\n      }\n      opt.data = params;\n    }\n    return new Promise(function (resolve, reject) {\n      axios(opt).then(result => resolve(result)).catch(error => {\n        if (error.response) {\n          error.type = "RESPONSE";\n        } else if (error.request) {\n          error.type = "REQUEST";\n        } else {\n          error.type = "CALL";\n        }\n        reject(error);\n      });\n    });\n  };\n  this.addHeader = function (name, value) {\n    let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'common\';\n    axios.defaults.headers[method][name] = value;\n  };\n  this.setBaseUrl = function (url) {\n    axios.defaults.baseURL = url;\n  };\n}\n\n//# sourceURL=webpack://webground/./src/channels/AxiosChannel.js?')},"./src/channels/FetchChannel.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchChannel: () => (/* binding */ fetchChannel)\n/* harmony export */ });\nfunction fetchChannel() {\n  this.baseURL = null;\n  this.headers = {\n    "Content-type": "application/x-www-form-urlencoded"\n  }; //"application/json; charset=UTF-8"\n}\n\nfetchChannel.prototype = {\n  send: function (opt) {\n    const config = {\n      method: opt.method,\n      headers: {\n        ...this.headers\n      }\n    };\n    if (!opt.url.startsWith("http") && this.baseURL) opt.url = this.baseURL + opt.url;\n    if (opt.method === "post") {\n      if (opt.data && !opt.excludeParams) {\n        const params = new URLSearchParams();\n        for (let key in opt.data) {\n          params.append(key, opt.data[key]);\n        }\n        opt.data = params;\n        config.body = params;\n      } else {\n        config.body = JSON.stringify(opt.data);\n        config.headers["Content-type"] = \'application/json\';\n      }\n    }\n    return new Promise(function (resolve, reject) {\n      fetch(opt.url, config).then(async response => {\n        console.log(response);\n        if (response.ok) {\n          response.config = opt;\n          response.data = await response.text();\n          try {\n            response.data = JSON.parse(response.data);\n          } catch (e) {}\n          resolve(response);\n        } else {\n          reject({\n            response: response,\n            type: "RESPONSE"\n          });\n        }\n      }, err => {\n        console.log(err);\n        err.type = "REQUEST";\n        reject(err);\n      }).catch(err => {\n        console.log(err);\n        err.type = "REQUEST";\n        throw err;\n      });\n    });\n  },\n  addHeader: function (name, value) {\n    this.headers[name] = value;\n  },\n  setBaseUrl: function (url) {\n    this.baseURL = url;\n  }\n};\n\n//# sourceURL=webpack://webground/./src/channels/FetchChannel.js?')},"./src/code.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   Flow: () => (/* binding */ Flow),\n/* harmony export */   ITask: () => (/* binding */ ITask),\n/* harmony export */   Task: () => (/* binding */ Task)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _observe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observe */ "./src/observe.js");\n\n\nfunction ITask() {}\n\n/*export function Task(task, data, key) {\r\n    this.task = task;\r\n\r\n    this.metadata\r\n\r\n    this.data = data;\r\n    this.key = key;\r\n    this.owner;\r\n    this.parent;\r\n    this.priority = 0;\r\n    this.input; //Generalizzare\r\n    this.disposable;\r\n    this.filter; //??\r\n    this.rule;\r\n}*/\nfunction Task(task, metadata, owner) {\n  this.task = task;\n  metadata && (this.metadata = metadata);\n}\nTask.Execute = function (task, info) {\n  return task instanceof ITask || task.execute ? task.execute(info) : task(info);\n};\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(ITask, Task, {\n  useMetadata: function (data) {\n    //if (!$Type.isObject(data)) data = { data }; ADD WORNING __DEV__\n    this.metadata = {\n      ...this.metadata,\n      ...data\n    };\n    return this;\n  },\n  useTempdata: function (data) {\n    this.tempdata = data;\n    return this;\n  },\n  usePolicy: function (policy) {\n    this.policy = policy;\n    return this;\n  },\n  /*useIntent: function (name, owner) {\r\n      return this.make(token => {\r\n          owner = owner || this.metadata?.owner;\r\n          if (owner instanceof Observable) owner.execute(name || token.event, token);\r\n      })\r\n  },*/\n\n  useKey: function (key) {\n    return this.useMetadata({\n      key\n    });\n  },\n  useInfo: function (info) {\n    return this.useMetadata({\n      info\n    });\n  },\n  useRule: function (rule, predicate) {\n    return this.useMetadata({\n      rule,\n      ...(predicate && {\n        predicate\n      })\n    });\n  },\n  usePriority: function (priority) {\n    return this.useMetadata({\n      priority\n    });\n  },\n  highPriority: function () {\n    return this.useMetadata({\n      priority: 20\n    });\n  },\n  mediumPriority: function () {\n    return this.useMetadata({\n      priority: 10\n    });\n  },\n  override: function (predicate) {\n    return this.useRule("override", predicate);\n  },\n  prepend: function () {\n    return this.useMetadata({\n      rule: "before"\n    });\n  },\n  last: function () {\n    return this.useMetadata({\n      rule: "last"\n    });\n  },\n  once: function () {\n    return this.useMetadata({\n      disposable: true\n    });\n  },\n  when: function (callback) {\n    if (!this.filter) this.filter = [];\n    this.filter.push(callback);\n    return this;\n  },\n  /** \r\n   * TOKEN FILTER (Example EMITTER)\r\n   * */\n\n  withKey: function (key) {\n    return this.when(token => token.key === key);\n  },\n  withTarget: function (target) {\n    return this.when(token => token.target === target);\n  },\n  /*withOwner: function (owner) {\r\n      return this.when((token => token.owner === owner))\r\n  },*/\n\n  etypeOf: function (etype) {\n    return this.when(token => token.etype === etype);\n  },\n  typeOf: function (type) {\n    return this.when(token => token.type === type);\n  },\n  deep: function (value) {\n    return this.when(token => token.deep === value);\n  },\n  /** \r\n   * END TOKEN FILTER\r\n   * */\n\n  make: function (callback) {\n    this.task = callback;\n    return this;\n  },\n  executable: function (token, temp) {\n    temp && (this.tempdata = temp);\n    const props = {\n      ...this.metadata,\n      ...this.tempdata,\n      ...token,\n      token\n    };\n    if (!this.task) return false;\n    if (this.filter) {\n      for (let k = 0; k < this.filter.length; k++) {\n        if (!Task.Execute(this.filter[k], props)) {\n          this.free();\n          return false; //value\n        }\n      }\n    }\n\n    return true;\n  },\n  execute: async function (token) {\n    const props = {\n      ...this.metadata,\n      ...this.tempdata,\n      ...token,\n      token\n    }; //CHI HA PRIORITA\' METADATA O TOKEN ???\n\n    this.task && (this.task instanceof ITask ? await this.task.execute(props) : await this.task(props));\n    this.free();\n    this.disposable && this.dispose();\n  },\n  /**\r\n   * Attach this task to currentFlow of main context\r\n   * @param {Function} callback \r\n   */\n\n  attach: function (callback) {\n    const flow = this.context.flow;\n    callback ? callback(flow)(this) : flow.task(this);\n  },\n  free: function () {\n    delete this.tempdata;\n  },\n  /**\r\n   * Capire bene generalizzazione di dispose....\r\n   */\n\n  dispose: function () {\n    const parent = this.metadata?.parent;\n    parent && parent.remove(this);\n  }\n});\n_core__WEBPACK_IMPORTED_MODULE_0__.core.inject(Task, "IContext");\n\n//this.args = [].slice.call(arguments, 1);\n\nfunction Block() {\n  this.await = [];\n  this.tasks = [];\n  this.executed;\n  //this.make.apply(this, arguments);\n}\n\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(ITask, Block, {\n  wait: function (task) {\n    this.await.push(task);\n  },\n  add: function () {\n    for (let k = 0; k < arguments.length; k++) {\n      if (this.executed) Task.Execute(arguments[k], this.executed);else this.tasks.push(arguments[k]);\n    }\n    return this;\n  },\n  execute: function (token) {\n    const blk = this;\n    Promise.all(this.await).then(result => {\n      blk.executed = token;\n      for (let key = 0; key < blk.tasks.length; key++) {\n        Task.Execute(blk.tasks[key], token);\n      }\n      this.reset();\n      return result;\n    });\n  },\n  reset: function () {\n    this.await = [];\n    this.tasks = [];\n    this.executed = undefined;\n  }\n});\nfunction Pointer() {\n  this.map = new Map();\n  this.block;\n  this.previous;\n}\nPointer.prototype = {\n  get next() {\n    return this.map.get(this.block);\n  },\n  //this.next = task.next;\n  //task.next = this;\n  link: function (task, section) {\n    const next = this.map.get(section);\n    this.map.set(task, next);\n    this.map.set(section, task);\n    return task;\n  },\n  forward: function () {\n    this.previous = this.block;\n    this.block = this.map.get(this.block);\n    return this.block;\n  },\n  seek: function (block) {\n    this.previous = null;\n    this.block = block;\n    return this;\n  },\n  jump: function () {\n    const previous = this.previous;\n    const block = this.block;\n    this.forward();\n    this.map.set(block, this.next);\n    this.previous = previous;\n    this.block = block;\n    //block.next = block.next.next;\n  }\n};\n\nfunction Flow() {\n  this._last;\n  this._output;\n  this._after;\n  this._task;\n  this._before;\n  this._input;\n  this._start;\n  this.pointer = new Pointer();\n  this.reset();\n}\nFlow.OVERRIDE = "override";\nFlow.FIRST = "first";\nFlow.LAST = "last";\nFlow.BEFORE = "before";\nFlow.AFTER = "after";\nFlow.BEFORE_OF = "beforeOf";\nFlow.AFTER_OF = "afterOf";\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(ITask, Flow, {\n  reset: function () {\n    const sections = ["_input", "_before", "_task", "_after", "_output", "_last"]; //,\n    this._start = new Task();\n    let actual = this._start;\n    sections.forEach(section => {\n      this[section] = this.pointer.link(new Task(), actual);\n      actual = this[section];\n    });\n    return this;\n  },\n  format: function (task, data, section) {\n    this.pointer.link(task instanceof Task ? task.useMetadata(data) : new Task(task, data), section);\n    return this;\n  },\n  task: function (task, data) {\n    return this.format(task, data, this._task);\n  },\n  output: function (task, data) {\n    return this.format(task, data, this._output);\n  },\n  input: function (task, data) {\n    return this.format(task, data, this._input);\n  },\n  import: function (task, data) {\n    //data && task.useMetadata(data)\n    if (task.metadata?.rule) {\n      const args = [task, data];\n      task.metadata.predicate && args.unshift(task.metadata.predicate);\n      this[task.metadata.rule].apply(this, args);\n    } else {\n      this.output(task, data);\n    }\n    return this;\n  },\n  first: function (task, data) {\n    return this.format(task, data, this._first);\n  },\n  last: function (task, data) {\n    return this.format(task, data, this._last);\n  },\n  before: function (task, data) {\n    return this.format(task, data, this._before);\n  },\n  after: function (task, data) {\n    return this.format(task, data, this._after);\n  },\n  find: function (predicate, parent) {\n    //const pointer = this.pointer.seek(this._start);\n    const pointer = this.pointer.seek(this._start);\n    while (pointer.block && !predicate(pointer.block)) pointer.forward(); //block.next.key !== key\n    return parent ? pointer.previous : pointer.block;\n  },\n  beforeOf: function (predicate, task, data) {\n    const block = this.find(predicate, true);\n    block && this.format(task, data, block);\n    return this;\n  },\n  afterOf: function (predicate, task, data) {\n    const block = this.find(predicate);\n    block && this.format(task, data, block);\n    return this;\n  },\n  //TODO: new implementation\n  override: function (predicate, task, data) {\n    const parent = predicate ? this.find(predicate, true) : this._task;\n    if (parent) {\n      const pointer = this.pointer.seek(parent);\n      pointer.jump();\n      this.format(task, data, parent);\n      //task.base = block;\n    }\n\n    return this;\n  },\n  remove: function (predicate) {\n    const block = this.find(predicate, true);\n    if (block) this.pointer.seek(block).jump(); //block.next = block.next.next;\n    return this;\n  },\n  execute: async function (token, preserve) {\n    const pointer = this.pointer.seek(this._start);\n    let block = pointer.next;\n    let result;\n    while (block) {\n      await block.execute(token);\n      if (token.stopFlow) break;\n      block = pointer.forward();\n    }\n    !preserve && this.reset();\n  }\n});\n\n/*first: function () {\r\n    return this.useMetadata({ rule: "first" });\r\n},\r\n\r\nlast: function () {\r\n    return this.useMetadata({ rule: "last" });\r\n},\r\n\r\nbefore: function () {\r\n    return this.useMetadata({ rule: "before" });\r\n},\r\n\r\nafter: function () {\r\n    return this.useMetadata({ rule: "after" });\r\n},\r\n\r\nbeforeOf: function (predicate) {\r\n    return this.useMetadata({ rule: "beforeOf", predicate });\r\n},\r\n\r\nafterOf: function (predicate) {\r\n    return this.useMetadata({ rule: "afterOf", predicate });\r\n},*/\n\n/*export function Block(task, data, metadata, key, next) {\r\n\r\n    this.event = event;\r\n    this.filter;\r\n    this.task; //Potrebbe sempre essere un block, ovvero se non lo è lo creo....\r\n    this.rule;\r\n\r\n    this.parent = parent;\r\n    this.owner = owner; //ok\r\n\r\n    this.input;\r\n    this.disposable;\r\n\r\n    return this;\r\n}\r\n\r\nBlock.prototype = {\r\n\r\n    prepend: function () {\r\n        this.input = true;\r\n        return this;\r\n    },\r\n\r\n    once: function () {\r\n        this.disposable = true;\r\n        return this;\r\n    },\r\n\r\n    when: function (callback) {\r\n        if (!this.filter) this.filter = [];\r\n        this.filter.push(callback);\r\n        return this;\r\n    },\r\n\r\n\r\n\r\n    target: function (target) {\r\n        return this.when((token => token.target === target))\r\n    },\r\n\r\n    etypeOf: function (etype) {\r\n        return this.when((token => token.etype === etype))\r\n    },\r\n\r\n    typeOf: function (type) {\r\n        return this.when((token => token.type === type))\r\n    },\r\n\r\n\r\n\r\n    make: function (callback, prepend) {\r\n        this.task = callback;\r\n        if (prepend) this.input = true;\r\n        return this;\r\n    },\r\n\r\n    policy: function (rule) {\r\n        this.rule = rule; return this;\r\n    },\r\n\r\n    executable: function (info) {\r\n        if (!this.task) return false;\r\n\r\n        if (this.filetr) {\r\n            for (let k = 0; k < this.filter.length; k++) {\r\n                if (!Task.execute(this.filter[k], info)) return false; //value\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    execute: function (info) {\r\n        return this.executable() && Task.execute(this.task, info);\r\n    },\r\n\r\n\r\n    dispose: function () {\r\n        this.parent && this.parent.remove(this);\r\n    }\r\n}*/\n\n//# sourceURL=webpack://webground/./src/code.js?')},"./src/context.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   context: () => (/* binding */ context)\n/* harmony export */ });\n/* harmony import */ var _observe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observe */ "./src/observe.js");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./code */ "./src/code.js");\n/* harmony import */ var _space__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./space */ "./src/space.js");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data */ "./src/data.js");\n/* harmony import */ var _breakpoint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./breakpoint */ "./src/breakpoint.js");\n/* harmony import */ var _binding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./binding */ "./src/binding.js");\n//import { core } from "./core";\n\n\n\n\n\n\n\nfunction context() {\n  _observe__WEBPACK_IMPORTED_MODULE_0__.Observable.call(this);\n  this.initialized = false;\n  this.built = false;\n  this.parent = null;\n  this.last = null;\n  this.current = this;\n  this.scope = this;\n  this.overridden = new Map();\n  this.breakpoint = new _breakpoint__WEBPACK_IMPORTED_MODULE_5__.BreakPointer();\n  this.block = new _code__WEBPACK_IMPORTED_MODULE_2__.Block();\n  this.binding = new _binding__WEBPACK_IMPORTED_MODULE_6__.Binder();\n  this.space = new _space__WEBPACK_IMPORTED_MODULE_3__.Space(); //DA VALUTARE\n}\n\n_core__WEBPACK_IMPORTED_MODULE_1__.core.prototypeOf(_observe__WEBPACK_IMPORTED_MODULE_0__.Observable, context, {\n  core: _core__WEBPACK_IMPORTED_MODULE_1__.core,\n  initialize: function (init) {\n    if (!this.initialized) {\n      this.initialized = true;\n      _core__WEBPACK_IMPORTED_MODULE_1__.core.build(this);\n      init && init(this);\n    }\n    return this;\n  },\n  focus: function (target) {\n    console.log("SCOPE-FOCUS", target, this.current);\n    target.parent = this.current;\n    this.current = target;\n  },\n  blur: function (target) {\n    console.log("SCOPE-BLUR", target, this.current);\n    this.current = target ? target.parent : this.current?.parent;\n    return true;\n  },\n  attachScope: function (type, key) {\n    if (this.scope === this) {\n      //this element is out of any scope => create one and push it on unscoped\n      _core__WEBPACK_IMPORTED_MODULE_1__.core.unscoped.push(this.setScope(new context()));\n    }\n    const scoped = this.scope.binding.bind(type, key);\n    scoped.scope = this.scope;\n    return scoped;\n  },\n  storeCurrent: function (current) {\n    this.last = {\n      value: this.current,\n      next: this.last\n    };\n    this.current = current;\n  },\n  restoreCurrent: function () {\n    this.current = this.last.value;\n    this.last = this.last.next;\n  },\n  updateScope: function (scoped) {\n    if (!this.scope.root) {\n      this.scope.root = scoped;\n      this.setScope(scoped.scope);\n    }\n    this.scope.storeCurrent(scoped);\n    scoped.parent = this.scope.actual;\n    this.scope.actual = scoped;\n\n    //this.scope.current = scoped;\n  },\n\n  setScope: function (scope) {\n    if (scope !== this.scope) {\n      console.log("SCOPE-SET", this.scope, scope);\n      scope.parent = this.scope; //--\x3eASSURANCE FOR OBSERVABLE CHAIN TOO\n      this.scope = scope;\n    }\n    return scope;\n  },\n  resetScope: function (root) {\n    this.scope.restoreCurrent();\n    this.scope.actual = root.parent;\n    if (this.scope.root === root) {\n      console.log("SCOPE-RESET", this.scope);\n      this.scope.root = null;\n      if (this.scope.parent) {\n        this.scope = this.scope.parent;\n      }\n    }\n  },\n  forward: function (target, key) {\n    if (this.current.assign) this.current.assign(target, key);\n  },\n  bind: function (type, path) {\n    return this.binding.firstOrCreate(type, path);\n  },\n  sync: function (mutation) {\n    if (mutation.$$typeof === _data__WEBPACK_IMPORTED_MODULE_4__.ES_DATA_OBJECT) mutation = mutation.mutation;\n    _core__WEBPACK_IMPORTED_MODULE_1__.core.source.sync(mutation);\n  },\n  setSource: async function (key, source) {\n    await source;\n    this.core.source.set(key, source);\n  },\n  getSource: function (key, initialValue) {\n    this.core.source.get(key, initialValue);\n  },\n  subscribe: function (target) {\n    if (this !== this.current) {\n      target.context = this.current;\n    }\n    this.space.share(target);\n    return target;\n  },\n  unscribe: function (target) {\n    this.space.unshare(target);\n  },\n  model: function (model, f) {\n    f(this.overridden.has(model) ? new this.overridden.get(model)(this) : new model(this));\n    //if(!m.istanceOfModel) throw new Error("MODEL call is not an istance of Model");\n  },\n\n  newInstance: function (etype, initialValues) {\n    return _data__WEBPACK_IMPORTED_MODULE_4__.$Data.cast(initialValues || {}, etype);\n  },\n  mutable: function (api) {\n    const mutable = new _data__WEBPACK_IMPORTED_MODULE_4__.MutableObject();\n    mutable.observable();\n    let props = {};\n    for (const key in api) {\n      if (key[0] === \'$\') {\n        props[key.substring(1)] = api[key];\n        delete api[key];\n      } else mutable[key] = api[key];\n    }\n    _core__WEBPACK_IMPORTED_MODULE_1__.core.observableProperty(mutable, props);\n    return mutable;\n  },\n  getControl: function (control, target) {\n    return this.overridden.has(control) ? new this.overridden.get(control)(this, target) : new control(this, target);\n  },\n  configureType: function (definition) {\n    this.core.typeDef = definition;\n    _data__WEBPACK_IMPORTED_MODULE_4__.$Data.buildSchema(definition);\n  },\n  setBaseUrl: function (url) {\n    this.core.services.iapi.channel.setBaseUrl(url);\n  },\n  configureService: function (services) {\n    services && Object.assign(_core__WEBPACK_IMPORTED_MODULE_1__.core.services, services);\n  },\n  configure: function (target, config) {\n    const proto = target.prototype;\n    proto.config = {\n      ...proto.config,\n      ...config\n    };\n  },\n  override: function (control) {\n    //assign to prototype control or set if not exist\n  }\n});\n\n//# sourceURL=webpack://webground/./src/context.js?')},"./src/core.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataSource: () => (/* binding */ DataSource),\n/* harmony export */   SimpleScheduler: () => (/* binding */ SimpleScheduler),\n/* harmony export */   TimeEvent: () => (/* binding */ TimeEvent),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   __DEV__: () => (/* binding */ __DEV__),\n/* harmony export */   core: () => (/* binding */ core),\n/* harmony export */   deferredAction: () => (/* binding */ deferredAction),\n/* harmony export */   donothing: () => (/* binding */ donothing),\n/* harmony export */   localStore: () => (/* binding */ localStore),\n/* harmony export */   sessionStore: () => (/* binding */ sessionStore),\n/* harmony export */   waitAction: () => (/* binding */ waitAction)\n/* harmony export */ });\n/* harmony import */ var _Apix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Apix */ "./src/Apix.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\n\nconst VERSION = "1.0.0";\nconst __DEV__ = true;\nfunction DataSource() {\n  this.map = new Map();\n  this.observers = new Map();\n}\nDataSource.prototype = {\n  sync: function (item) {\n    this.map.forEach((source, key) => {\n      if (!Array.isArray(source)) source = [source];\n      for (let k = 0; k < source.length; k++) {\n        source[k].sync && source[k].sync(item); //core.implementOf(Symbol.for(\'es.isync\'), source[k])\n      }\n    });\n  },\n\n  add: function (key, source) {\n    if (this.map.has(key)) {\n      this.map.get(key).push(source);\n    } else {\n      this.map.set(key, [source]);\n    }\n  },\n  remove: function (key) {\n    this.map.delete(key);\n  },\n  get: function (key, initValue) {\n    if (initValue && !this.map.has(key)) this.map.set(key, initValue);\n    return this.map.get(key);\n  },\n  set: function (key, value) {\n    this.map.set(key, value);\n    if (this.observers.size > 0) {\n      this.observers.forEach((v, obs) => v === key && obs());\n    }\n  },\n  subscribe: function (key, observer) {\n    this.observers.set(observer, key);\n  },\n  unscribe: function (observer) {\n    this.observers.delete(observer);\n  }\n};\nconst core = {\n  built: false,\n  context: null,\n  _metadata: new WeakMap(),\n  source: new DataSource(),\n  metadata: function (target) {\n    !this._metadata.has(target) && this._metadata.set(target, new Metadata());\n    return this._metadata.get(target);\n  },\n  services: {\n    iapi: _Apix__WEBPACK_IMPORTED_MODULE_0__.Apix\n  },\n  unscoped: [],\n  _shared: new Map(),\n  /** for now support only model sharing */\n  share: function (data) {\n    const scope = this.context.scope;\n    this.source.add(scope, data);\n  },\n  unshare: function (scope) {\n    this.source.remove(scope);\n    if (this.unscoped.length > 0) {\n      this.unscoped.forEach(s => this.source.remove(s));\n      this.unscoped.length = 0;\n    }\n  },\n  getCookie: name => document.cookie.match(\'(^|;)\\\\s*\' + name + \'\\\\s*=\\\\s*([^;]+)\')?.pop() || null,\n  document: {\n    oncontent: function (f) {\n      document.addEventListener("DOMContentLoaded", f);\n    },\n    onload: function (f) {\n      window.addEventListener(\'onload\', f);\n    },\n    onunload: function (f) {\n      document.addEventListener("visibilitychange", f);\n      window.addEventListener("pagehide", f, false);\n      document.addEventListener(\'beforeunload\', f);\n    }\n  },\n  observableProperty: function (proto, target) {\n    for (const key in target) {\n      Object.defineProperty(proto, \'$\' + key, {\n        get: function () {\n          return this[key];\n        },\n        set: function (value) {\n          this.mutate(key, value);\n        }\n      });\n      if (target[key] !== null) proto[key] = target[key];\n    }\n  },\n  create: function (api) {\n    if (__DEV__) {\n      (!api || typeof api !== \'object\') && console.error("Wrong class api definition");\n    }\n    const constructor = api.$constructor || function () {};\n    const proto = constructor.prototype;\n    if (api.hasOwnProperty("$observable")) {\n      this.observableProperty(proto, api.$observable);\n      delete api.$observable;\n    }\n    if (api.hasOwnProperty("$properties")) {\n      Object.defineProperties(proto, api.$properties);\n      delete api.$properties;\n    }\n    if (api.hasOwnProperty("$inject")) {\n      core.inject(constructor, api.$inject);\n      delete api.$inject;\n    }\n    Object.assign(proto, api);\n    return constructor;\n  },\n  extend: function (base, api) {\n    if (!api.hasOwnProperty("$constructor")) api.$constructor = function () {\n      base.apply(this, arguments);\n    };\n    api.$constructor.prototype = Object.create(base.prototype);\n    api.$constructor.prototype.constructor = api.$constructor;\n    const constructor = this.create(api);\n    return constructor;\n  },\n  implementOf: function (source, target) {\n    return target.implement && target.implement.findIndex(v => v === source) > -1;\n  },\n  prototypeOf: function (source, target, api, properties) {\n    //TODO: support array of source\n    target.prototype = Object.create(source.prototype, {\n      constructor: {\n        value: target,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      $$type: {\n        value: target\n      }\n    });\n    if (api) {\n      if (api.hasOwnProperty("$observable")) {\n        this.observableProperty(proto, api.$observable);\n        delete api.$observable;\n      }\n      if (source.prototype.intent) target.prototype.$$base = source.prototype.intent;\n\n      //Object.assign(target.prototype, api);\n      // $ indica extend property\n      let k, value;\n      for (const key in api) {\n        if (key[0] === "$" && key[1] !== "$") {\n          k = key.substring(1);\n          value = {\n            ...source.prototype[k],\n            ...api[key]\n          };\n        } else {\n          k = key;\n          value = api[key];\n        }\n        Object.defineProperty(target.prototype, k, {\n          value: value,\n          writable: true\n        });\n      }\n    }\n    if (properties) {\n      for (const key in properties) {\n        Object.defineProperty(target.prototype, key, properties[key]);\n      }\n    }\n\n    //api && Object.assign(target.prototype, api);\n\n    return target.prototype;\n  },\n  inject: function (type, services) {\n    services = services.split(\',\');\n    services.forEach(service => {\n      service = service.trim().toLowerCase();\n      Object.defineProperty(type.prototype, service.slice(1), {\n        get: function () {\n          return this[service] || core.services[service];\n        },\n        set: function (value) {\n          this[service] = value;\n        }\n      });\n    });\n  },\n  setIntent: function (type, intent) {\n    const proto = type.prototype;\n    if (proto.hasOwnProperty("intent")) Object.assign(proto.intent, intent);else proto.intent = intent;\n  },\n  build: function (ctx) {\n    if (!this.built) {\n      this.built = true;\n      this.setContext(ctx);\n    }\n  },\n  setContext: function (ctx) {\n    this.context && this.context.dispose();\n    this.context = ctx;\n    this.services.icontext = ctx;\n\n    /*ctx.observe("MUTATED").make(({ target, emitter }) => {\r\n        emitter.node.Mutation.push(target.mutation);\r\n    })\r\n      ctx.observe("IMMUTATED").make(({ target, emitter }) => {\r\n        $Array.remove(emitter.node.Mutation, m => m.id === target.id)\r\n    })*/\n  }\n};\n\nfunction Metadata() {\n  this.source = new Map();\n}\nMetadata.prototype = {\n  get: function (key, type) {\n    !this.source.has(key) && this.source.set(key, type ? new type() : {});\n    return this.source.get(key);\n  },\n  set: function (key, value) {\n    this.source.set(key, value);\n  }\n};\nconst donothing = () => undefined;\n\n//should be Promise?\nconst localStore = {\n  save: function (wobj) {\n    localStorage.setItem(wobj.etype + \'__\', JSON.stringify(wobj));\n  },\n  getData: function (wobj) {\n    return JSON.parse(localStorage.getItem(wobj.etype + \'__\'));\n  },\n  clear: function (wobj) {\n    return localStorage.removeItem(wobj.etype + \'__\');\n  }\n};\nconst sessionStore = {\n  save: function (wobj) {\n    sessionStorage.setItem(wobj.etype + \'__\', JSON.stringify(wobj));\n  },\n  getData: function (wobj) {\n    return JSON.parse(sessionStorage.getItem(wobj.etype + \'__\'));\n  },\n  clear: function (wobj) {\n    return sessionStorage.removeItem(wobj.etype + \'__\');\n  }\n};\nfunction TimeEvent() {\n  this.datetime = null; //Convert...\n  this.task = null;\n  this.data = null;\n  this.timer = null;\n}\n\n/**\r\n * TODO: check if timer exist when go in background timer can be canceled o late, when riactive restart?\r\n */\nfunction SimpleScheduler() {\n  this.events = null;\n  this.current = null;\n}\nSimpleScheduler.prototype = {\n  add: function (event) {},\n  remove: function (event) {},\n  update: function () {\n    if (this.events) {\n      this.events.sort((a, b) => a.datetime - b.datetime);\n      if (this.events[0] !== this.current) {\n        this.restart();\n      }\n    }\n  },\n  start: function () {\n    if (this.events) {\n      const event = this.events[0];\n      const time = event.datatime - new Date();\n      this.timer = setTimeout(data => {\n        event.task(data);\n        this.next();\n      }, time, event.data);\n    }\n  },\n  next: function () {\n    if (this.tasks) {\n      //const task = \n    }\n  },\n  stop: function () {\n    clearTimeout(this.timer);\n  },\n  restart: function () {\n    this.stop();\n    this.start();\n  }\n};\nfunction deferredAction(action, offset) {\n  if (!action) throw new Error("deferredAction must define action on constructor.");\n  this.waiting = false;\n  this.offset = offset || 500;\n  this.timer = null;\n  this.execute = function () {\n    if (!this.waiting) {\n      this.waiting = setTimeout((() => {\n        this.waiting = false;\n        action();\n      }).bind(this), this.offset);\n    }\n  };\n  this.setOffset = function (value) {\n    this.offset = value;\n    this.execute();\n    /*if(this.waiting){\r\n        clearTimeout(this.waiting);\r\n        this.waiting = false;  \r\n    }*/\n  };\n}\n\nfunction waitAction(action, wait) {\n  this.time = null;\n  this.action = action;\n  const instance = this;\n  this.deferred = new deferredAction(() => {\n    const noaction = new Date().getTime() - instance.time.getTime();\n    const w = wait || 500;\n    console.log("NO ACTION", noaction, w, w - w * 2 / 10);\n    noaction > w - w * 2 / 10 ? instance.action() : instance.deferred.setOffset(w - noaction);\n  }, wait || 500);\n  this.execute = function () {\n    this.time = new Date();\n    this.deferred.execute();\n  };\n  this.executeNow = function () {\n    this.action();\n  };\n}\n\n//# sourceURL=webpack://webground/./src/core.js?')},"./src/data.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $Data: () => (/* binding */ $Data),\n/* harmony export */   DataCollection: () => (/* binding */ DataCollection),\n/* harmony export */   DataObject: () => (/* binding */ DataObject),\n/* harmony export */   ES_DATA_OBJECT: () => (/* binding */ ES_DATA_OBJECT),\n/* harmony export */   ISync: () => (/* binding */ ISync),\n/* harmony export */   MutableObject: () => (/* binding */ MutableObject),\n/* harmony export */   Mutation: () => (/* binding */ Mutation)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph */ "./src/graph.js");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model */ "./src/model.js");\n/* harmony import */ var _observe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observe */ "./src/observe.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\n\n\n\n\nfunction MutableObject() {}\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(_observe__WEBPACK_IMPORTED_MODULE_3__.Observable, MutableObject, {\n  mutate: function (field, value) {\n    this[field] !== value && this.mutation.setValue(field, value);\n  },\n  observable: function () {\n    this.mutation.observable = true;\n  }\n}, {\n  hasMutation: {\n    get: function () {\n      return this.__mutation !== undefined;\n    }\n  },\n  mutation: {\n    get: function () {\n      if (!this.__mutation) Object.defineProperty(this, \'__mutation\', {\n        enumerable: false,\n        writable: true,\n        value: new Mutation(this)\n      });\n      return this.__mutation;\n    }\n  }\n});\nconst ES_DATA_OBJECT = Symbol.for(\'es.dataobject\');\nconst ISync = Symbol.for(\'es.isync\');\nfunction DataObject(etype, data) {\n  if (data) return $Data.cast(data, etype);\n  MutableObject.call(this);\n  // Per creare istanza type con new solo se data è null, altrimenti fare cast\n  Object.defineProperty(this, \'_parent\', {\n    enumerable: false,\n    writable: true,\n    value: etype ? $Data.createGraph(etype, false, "root").setSource(this) : null\n  });\n}\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(MutableObject, DataObject, {\n  //$$typeof: ES_DATA_OBJECT,\n\n  save: function (all) {\n    return this.node.save(all ? null : this);\n  },\n  delete: function () {\n    this.node.delete(this);\n  },\n  remove: function () {\n    this.node.remove(this);\n  },\n  sync: function (item) {\n    return this.node.sync(this, item);\n  },\n  /**\r\n   * \r\n   * @param {*} source mutation instance\r\n   * source?.mutation?.mutated\r\n   */\n  update: function (source) {\n    Object.assign(this, source?.mutated);\n  }\n}, {\n  node: {\n    enumerable: false,\n    get: function () {\n      return this._node ? this._node : this._parent.node;\n    },\n    set: function (value) {\n      this._node = value;\n    }\n  },\n  parent: {\n    enumerable: false,\n    get: function () {\n      return Array.isArray(this._parent) ? this._parent.parent : this._parent;\n    },\n    set: function (value) {\n      this._parent = value;\n    }\n  }\n});\nObject.defineProperty(DataObject.prototype, \'$$typeof\', {\n  enumerable: false,\n  writable: false,\n  value: ES_DATA_OBJECT\n});\nfunction DataCollection(etype, source) {\n  if (!source) source = [];\n  if (!Array.isArray(source)) throw new Error("DataCollection: source must by Array Type");\n  return $Data.cast(source, etype);\n}\nconst $Data = {\n  cast: function (data, etype) {\n    if (!data) return data; //controllare se è già cast\n    //data = data || {};\n    //Check if object => Warning or cast error // Check type by key\n    return this.createGraph(etype, Array.isArray(data), "root").setSource(data).source;\n  },\n  createGraph: function (etype, collection, name) {\n    return new _graph__WEBPACK_IMPORTED_MODULE_1__.Graph().parse(etype, collection, name);\n  },\n  /*build: function (data, node, parent) {\r\n      return node.isCollection\r\n          ? this.CreateCollection(data, parent, node)\r\n          : this.CreateObject(data, parent, node)\r\n  },*/\n\n  build: function (data, node, parent) {\n    node.traverse(function (node, data, parent) {\n      if (!data) return;\n      if (data.$$typeof !== ES_DATA_OBJECT) {\n        const obj = node.isCollection ? $Data.CreateCollection(data, parent, node) : $Data.CreateObject(data, parent, node);\n        if (parent) parent[node.name] = obj;\n      } else {\n        parent && parent.node.replace(node.name, data.node);\n        return _graph__WEBPACK_IMPORTED_MODULE_1__.FLOW_STOP;\n      }\n    }, true, data, parent);\n    return data;\n  },\n  CreateObject: function (data, parent, node) {\n    Object.setPrototypeOf(data, node.type.prototype);\n    data.parent = parent;\n    data.node = node;\n    node.formatData(data, parent);\n    return data;\n  },\n  CreateCollection: function (data, parent, node) {\n    //data.$isDataObject = () => true;\n    const parse = function (args, start) {\n      const n = data.node;\n      start = start || 0;\n      let item;\n      for (let i = start; i < args.length; i++) {\n        item = args[i];\n        if (!item) continue;\n        if (item.$$typeof !== ES_DATA_OBJECT)\n          //(!(item instanceof node.type)) \n          args[i] = Object.setPrototypeOf(item, n.type.prototype);else {\n          n.traverse((n, source) => {\n            if (source) source.node = n;\n            if (!Array.isArray(source)) source = [source];\n            source.forEach(obj => obj && obj.hasMutation && n.Mutation.push(obj.mutation));\n          }, true, item);\n          delete item._node;\n        }\n        item.parent = data;\n      }\n      n.formatData(args, parent);\n      return args;\n    };\n    if (!Array.isArray(data)) {\n      data = [];\n      parent[node.name] = data;\n    }\n    Object.defineProperty(data, \'node\', {\n      writable: true,\n      enumerable: false,\n      value: node\n    });\n    Object.defineProperty(data, \'parent\', {\n      writable: true,\n      enumerable: false,\n      value: parent\n    });\n    parse(data);\n    const nativePush = Array.prototype.push;\n    data.push = function () {\n      //parse([].slice.call(arguments));\n      nativePush.apply(this, parse([].slice.call(arguments)));\n    };\n    const nativeUnshift = Array.prototype.unshift;\n    data.unshift = function () {\n      //parse(arguments);\n      nativeUnshift.apply(this, parse([].slice.call(arguments)));\n    };\n    const nativeSplice = Array.prototype.splice;\n    data.splice = function () {\n      // parse(arguments, 2);\n      nativeSplice.apply(this, parse([].slice.call(arguments), 2));\n    };\n    data.sync = function (item) {\n      return this.node.sync(this, item);\n    };\n    data.$$typeof = ES_DATA_OBJECT;\n    return data;\n  },\n  clone: function (data) {\n    return Object.setPrototypeOf({\n      ...data\n    }, data.node.type.prototype);\n  },\n  createProperty: function (target, name) {\n    Object.defineProperty(target, name, {\n      get: function () {\n        return this[name];\n      },\n      set: function (value) {\n        this.mutate(name, value);\n      }\n    });\n  },\n  createProperties: function (etype, eschema) {\n    const schema = eschema[etype]; //core.EntitySchema[etype];\n\n    if (!schema || !schema.type) throw new Error(etype + ": Type or Schema definition missing.");\n    schema.type.prototype.$$etype = etype;\n    for (let key in schema.fields) {\n      Object.defineProperty(schema.type.prototype, \'$\' + key, {\n        set: function (value) {\n          this.mutate(key, value);\n        }\n      });\n    }\n    schema.children && schema.children.forEach(info => {\n      //const s = webground.EntitySchema[info.etype];\n      const key = info.name;\n      Object.defineProperty(schema.type.prototype, \'$\' + key, {\n        get: function () {\n          let child = this[key];\n          if (info.collection && !child) {\n            child = [];\n            this[key] = child;\n          }\n          if (child && child.$$typeof !== Symbol.for(\'es.dataobject\')) {\n            this[key] = $Data.build(child, this.node.getChild(key), this);\n            child = this[key];\n          }\n          return child;\n        },\n        set: function (value) {\n          if (value) {\n            if (value.$$typeof !== Symbol.for(\'es.dataobject\')) value = $Data.build(value, this.node.getChild(key), this);else {\n              this.node.replace(key, value.node);\n              value.node.formatData(value, this);\n            }\n          }\n          this[key] = value;\n          //Emit Children Changed ???\n        }\n      });\n    });\n\n    //qui posso cancellare volendo definizione di fields e children\n  },\n\n  buildSchema: function (eschema) {\n    eschema = eschema || _core__WEBPACK_IMPORTED_MODULE_0__.core.typeDef;\n    for (const key in eschema) {\n      const schema = eschema[key];\n      if (!schema.hasOwnProperty("type")) {\n        //Costructor name...\n        //const type = { [key]: function () { DataObject.call(this); } }\n        schema.type = {\n          [key]: function () {\n            DataObject.call(this);\n          }\n        }[key]; //type[key];\n        _core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(DataObject, schema.type);\n      }\n      this.createProperties(key, eschema);\n    }\n  },\n  hasType: obj => obj.$$typeof === Symbol.for(\'es.dataobject\'),\n  entities: {\n    nextIndex: function (etype) {\n      if (!this[etype]) this[etype] = 0;\n      return this[etype]--;\n    }\n  }\n};\nfunction Mutation(target) {\n  Object.defineProperty(this, \'target\', {\n    enumerable: false,\n    writable: true,\n    value: target\n  });\n  Object.defineProperty(this, \'session\', {\n    enumerable: false,\n    writable: true,\n    value: {}\n  });\n  Object.defineProperty(this, \'original\', {\n    enumerable: false,\n    writable: true,\n    value: {}\n  });\n  this.id = target.id;\n  this.mutated = {};\n  this.count = 0;\n  this.tempkey = null;\n  this.linked = null;\n  target.__mutation = this;\n}\nMutation.prototype = {\n  setValue: function (field, value) {\n    const target = this.target;\n    if (this.original[field] === value) {\n      //caso undefined non compreso\n      delete this.mutated[field];\n      delete this.original[field];\n      delete this.session[field];\n      if (--this.count === 0) {\n        //delete target.__mutation;\n        target.node && _utils__WEBPACK_IMPORTED_MODULE_4__.$Array.remove(emitter.node.Mutation, m => m.id === target.id);\n        target.mutating = target.emit("IMMUTATED", target, target);\n      }\n    } else {\n      if (!this.original.hasOwnProperty(field)) {\n        this.original[field] = target[field];\n        this.count++;\n        if (this.count === 1) {\n          target.node && target.node.Mutation.push(this);\n          target.mutating = target.emit("MUTATED", target, target); //.then(()=>target.mutating=null);\n        }\n      }\n\n      this.session[field] = {\n        value,\n        old: this.mutated[field],\n        original: this.original[field]\n      };\n      this.mutated[field] = value;\n    }\n    this.target[field] = value;\n    this.observable && target.emit("MUTATING", {\n      target,\n      value,\n      field,\n      old: this.mutated[field],\n      original: this.original[field]\n    });\n  },\n  notify: function () {\n    for (const key in this.session) {\n      this.target.emit("MUTATING", this.session, this.target);\n      this.session = {};\n      break;\n    }\n  },\n  restore: function () {\n    for (const key in this.mutated) {\n      this.target[key] = this.original[key];\n    }\n  },\n  clear: function () {\n    delete this.target.__mutation;\n  }\n};\n\n/**\r\n * SELECT\r\n    column_name,\r\n    data_type\r\nFROM\r\n    information_schema.columns\r\nWHERE\r\n    table_name = \'table_name\';\r\n\r\n\r\n        this.observe = function (evt) {\r\n        return this.node.observe(evt).target(this);\r\n    }\r\n\r\n    this.emit = function (evt, data) {\r\n        this.node.emit(evt, data, this);\r\n    }\r\n\r\n    this.setValue = target.managed\r\n        ? function (field, value) {\r\n            if (this.original[field] === value) {\r\n                delete this.mutated[field];\r\n                if (--this.count === 0) {\r\n                    delete target.__mutation;\r\n                    ///target.immutable();\r\n                    target.emit("IMMUTATED", target, target);\r\n                }\r\n            }\r\n            else {\r\n\r\n                if (!this.original.hasOwnProperty(field)) {\r\n                    this.original[field] = target[field];//value;\r\n                    this.count++;\r\n                    this.count === 1 && target.emit("MUTATED", target, target);\r\n                }\r\n\r\n                this.mutated[field] = value;\r\n                this.target[field] = value;\r\n                target.emit("MUTATING", { field, value, oldValue: this.original[field], object: target }, target);\r\n            }\r\n        }\r\n\r\n        : function (field, value) {\r\n            this.mutated[field] = value;\r\n            const oldValue = this.target[field];\r\n            this.target[field] = value;\r\n            target.emit("MUTATING", { field, value, oldValue: oldValue }, target);\r\n        }\r\n\r\n    this.restore = function () {\r\n        if (this.managed) {\r\n            for (const key in this.mutated) {\r\n                this.target[key] = this.original[key];\r\n            }\r\n        }\r\n    }\r\n */\n\n//# sourceURL=webpack://webground/./src/data.js?')},"./src/graph.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BottomLink: () => (/* binding */ BottomLink),\n/* harmony export */   DoubleLink: () => (/* binding */ DoubleLink),\n/* harmony export */   FLOW_STOP: () => (/* binding */ FLOW_STOP),\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   GraphLink: () => (/* binding */ GraphLink),\n/* harmony export */   GraphNode: () => (/* binding */ GraphNode),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   TopLink: () => (/* binding */ TopLink)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./src/data.js");\n/* harmony import */ var _observe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observe */ "./src/observe.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\n\n\n\nfunction Graph() {\n  Object.defineProperty(this, \'source\', {\n    enumerable: false,\n    writable: true\n  });\n\n  /** @type {GraphNode} */\n  Object.defineProperty(this, \'root\', {\n    enumerable: false,\n    writable: true\n  });\n\n  /** @type {boolean} Tell if graph remain available in memory after context dispose*/\n  this.permanent;\n  this.setSource = function (data) {\n    if (data) {\n      if (data.$$typeof !== Symbol.for(\'es.dataobject\')) {\n        data = _data__WEBPACK_IMPORTED_MODULE_1__.$Data.build(data, this.root, this);\n      } else {\n        data.node = this.root; //invertire?\n        data.parent = this;\n      }\n    }\n    console.log("GRAPH SET SOUCE", data);\n    this.source = data;\n    return this;\n  };\n  this.parse = function (etype, collection, name) {\n    this.root = new GraphNode(null, {\n      ..._core__WEBPACK_IMPORTED_MODULE_0__.core.typeDef[etype],\n      etype,\n      collection,\n      name\n    }, this);\n    return this;\n  };\n}\nconst FLOW_STOP = "S";\nfunction GraphNode(parent, schemaInfo, graph, path) {\n  _observe__WEBPACK_IMPORTED_MODULE_2__.Observable.call(this);\n  Object.defineProperty(this, \'parent\', {\n    enumerable: false,\n    writable: true,\n    value: parent\n  });\n  Object.defineProperty(this, \'graph\', {\n    enumerable: false,\n    writable: true,\n    value: graph\n  });\n  Object.defineProperty(this, \'type\', {\n    enumerable: false,\n    writable: true\n  });\n  this.path = path || "root";\n  this.isCollection;\n  this.children = [];\n  this.Mutation = [];\n  this.primarykey;\n  this.identity;\n  this.link;\n  this.name = "root";\n  this.etype;\n  this.TypeSchema = null;\n  if (schemaInfo) this.parse(schemaInfo, graph);\n}\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(_observe__WEBPACK_IMPORTED_MODULE_2__.Observable, GraphNode, {\n  parse: function (info, graph) {\n    this.name = info.name;\n    this.isCollection = info.collection;\n    this.etype = info.etype;\n    this.primarykey = info.primarykey || "id";\n    this.identity = info.hasOwnProperty("identity") ? info.identity : true;\n    this.link = Link.parse(info.link || Link.DOWN_WISE, this);\n    const schema = _core__WEBPACK_IMPORTED_MODULE_0__.core.typeDef[this.etype];\n    if (!schema) throw new Error("GraphNode PARSER: Schema not defined for Entity " + this.etype); //DEV CODE => WARNING SYSTEM\n    this.type = schema.type;\n    this.TypeSchema = schema.fields;\n    schema.children && schema.children.forEach(info => this.children.push(new GraphNode(this, info, graph, this.path + \'.\' + info.name)));\n    return this;\n  },\n  getChild: function (name) {\n    return this.children ? this.children.find(child => child.name === name) : null;\n  },\n  replace: function (name, node) {\n    const index = this.children ? this.children.findIndex(child => child.name === name) : -1;\n    if (index !== -1) {\n      node.link = this.children[index].link;\n      //dovrei sistemare anche path\n      this.children[index] = node;\n    }\n  },\n  discendant: function (path) {\n    if (!path) return null;\n    let n = this;\n    path.split(\'.\').forEach(name => n = n.getChild(name));\n    return n;\n  },\n  /**\r\n   * @param {traverseCallback} callback \r\n   * @param {boolean} deep \r\n   * @param {*} source \r\n   * @param {*} ancestor \r\n   * @param {boolean} generate \r\n   * @returns \r\n   */\n  traverse: function (callback, deep, source, ancestor, generate) {\n    const stop = callback(this, source, ancestor);\n    if (!this.children || FLOW_STOP === stop) return stop;\n    for (let k = 0; k < this.children.length; k++) {\n      if (generate) source[this.children[k].name] = {};\n      if (deep) {\n        if (source) {\n          if (Array.isArray(source)) {\n            for (let j = 0; j < source.length; j++) {\n              const parent = source[j];\n              if (!parent) continue;\n              if (this.children[k].traverse(callback, deep, parent[this.children[k].name], parent, generate) === FLOW_STOP) break;\n            }\n          } else this.children[k].traverse(callback, deep, source[this.children[k].name], source, generate);\n        } else this.children[k].traverse(callback, deep, null, source, generate);\n      } else callback(this.children[k], source ? source[this.children[k].name] : null, source, generate);\n    }\n  },\n  /**\r\n  * @param {*} data \r\n  * @param {*} parent \r\n  * @returns \r\n  * consider root element has graph as parent\r\n  */\n  formatData: function (data, parent, notrack) {\n    console.log("DEBUG-NODE-FORMAT", data, parent);\n    if (!Array.isArray(data)) data = [data];\n    if (!data[0]) return;\n    //here we assume that if first element are linked then all element are linked\n    if (this.link?.connected(data[0]) || !parent && data[0].hasOwnProperty("id")) return FLOW_STOP; // oppure id > 0\n\n    for (let k = 0; k < data.length; k++) {\n      const source = data[k];\n      if (!source) continue;\n      if (!source.hasOwnProperty("id") && Object.isExtensible(source)) {\n        //notrack??\n        if (!notrack) {\n          const mutation = source.mutation;\n          for (const key in _core__WEBPACK_IMPORTED_MODULE_0__.core.typeDef[this.etype].fields) {\n            if (Object.hasOwnProperty.call(source, key)) {\n              mutation.setValue(key, source[key]);\n            }\n          }\n        }\n        source.id = _data__WEBPACK_IMPORTED_MODULE_1__.$Data.entities.nextIndex(this.etype);\n        if (source.hasMutation) source.__mutation.id = source.id;\n      }\n      parent && this.link && this.link.apply(source, this, parent); //if parent === graph => non esiste link....\n\n      //console.log("DEBUG-NODE-FORMAT-SOURCE", parent, source, this.link, this);\n    }\n  },\n\n  deepFormat: function (data, parent, notrack) {\n    this.traverse((node, data, parent) => {\n      node.formatData(data, parent, notrack);\n    }, true, data, parent);\n  },\n  /** TODO: handle case of dataobject =>  */\n  sync: function (source, item) {\n    let syncronized = false;\n    const mutation = item.mutation;\n    this.traverse((node, data, parent) => {\n      if (node.etype === item.$$etype) {\n        if (!data) return;\n        const isCollection = Array.isArray(data);\n        if (mutation.crud === 1) {\n          //da gestire condition di appartenenza x aggiungere\n          isCollection ? data.push(item) : null; // da gestire caso parent in base a link...parent[node.name] = mutation;\n          syncronized = true;\n        } else {\n          if (!isCollection) data = [data];\n          let obj;\n          for (let k = 0; k < data.length; k++) {\n            obj = data[k];\n            if (obj && item.id === obj.id) {\n              if (mutation.crud === 3) {\n                isCollection ? data.splice(k, 1) : parent[node.name] = null;\n                syncronized = true;\n              } else if (item !== obj) {\n                obj.update(mutation);\n                syncronized = true;\n              }\n            }\n          }\n        }\n      }\n    }, true, source);\n    return syncronized;\n  },\n  save: function (option) {\n    const defaultOpt = {\n      queryOp: this.api.queryOp,\n      excludeParams: true\n    };\n    Object.assign(defaultOpt, option);\n    console.log(JSON.stringify(this));\n    return this.api.call(defaultOpt.queryOp, this, defaultOpt).then(result => {\n      console.log("Node Save RESULT:", result);\n      result.items = [];\n      this.Mutation.forEach(m => result.items.push(m.target));\n      if (result.items.length > 0) result.item = result.items[0];\n      this.traverse(node => {\n        /**\r\n         * update id key from remote insert\r\n         * TODO: add other value to update from remote other then id\r\n         */\n        if (result.data.mutation) {\n          const m = result.data.mutation[node.etype];\n          if (m) {\n            m.forEach(el => {\n              if (el.index < 1) {\n                const item = node.Mutation.find(m => m.id === el.index);\n                console.log("NODE-SAVE-REMOTE-INDEX", el, item);\n                if (item) {\n                  item.id = el.id;\n                  item.target.id = el.id;\n                }\n              }\n            });\n          }\n        }\n        node.Mutation.forEach(function (m, key) {\n          console.log("MUTATION-CLEAR-LOG", m, key);\n          _core__WEBPACK_IMPORTED_MODULE_0__.core.source.sync(m.target);\n          m.clear();\n        });\n        node.Mutation = [];\n      }, true);\n      return result;\n    }, er => {\n      console.log("ERROR GraphNode Save", er);\n      throw er;\n    });\n  },\n  delete: function (data, option) {\n    const defaultOpt = {\n      delOp: "api/jdelete",\n      excludeParams: true\n    };\n    Object.assign(defaultOpt, option);\n    if (!Array.isArray(data)) data = [data];\n    const mutation = [];\n    data.forEach(item => {\n      //item.mutation.crud = 3;\n      item.id < 1 ? this.remove(data) : mutation.push(item.mutation);\n    });\n    return this.api.call(defaultOpt.delOp, {\n      etype: this.etype,\n      Mutation: mutation\n    }, defaultOpt).then(() => {\n      this.remove(data);\n    });\n  },\n  remove: function (data) {\n    if (!Array.isArray(data)) data = [data];\n    data.forEach(item => {\n      item.mutation.crud = 3;\n      _core__WEBPACK_IMPORTED_MODULE_0__.core.source.sync(item);\n      _utils__WEBPACK_IMPORTED_MODULE_3__.$Array.removeItem(this.Mutation, item.mutation);\n    });\n  }\n});\n_core__WEBPACK_IMPORTED_MODULE_0__.core.inject(GraphNode, "IApi");\nconst Link = {\n  DOWN_WISE: \'d\',\n  UP_WISE: \'u\',\n  BIDIRECTIONAL: \'b\',\n  parse: function (direction, node) {\n    if (direction === Link.DOWN_WISE) {\n      const schema = node.parent;\n      if (!schema) return null;\n      //per ora non gestisco multi key\n      return new BottomLink(schema.primarykey, schema.primarykey + schema.etype, direction);\n    } else if (direction === Link.UP_WISE) {\n      //per ora non gestisco multi key\n      return new TopLink(node.primarykey, node.primarykey + node.etype, direction);\n    } else if (direction === Link.BIDIRECTIONAL) {\n      const pschema = node.parent;\n      if (!pschema) return null;\n      return new DoubleLink(pschema.etype + pschema.primarykey, node.etype + node.primarykey, direction, pschema.etype + "_" + node.etype);\n    }\n  }\n};\nfunction GraphLink(pk, fk, direction, association) {\n  this.pk = pk;\n  this.fk = fk;\n  this.direction = direction;\n  this.association = association;\n}\nfunction BottomLink(pk, fk, direction, association) {\n  GraphLink.call(this, pk, fk, direction, association);\n  /**\r\n   * @param {*} parent \r\n   * @param {*} child \r\n   * @param {GraphNode} node \r\n   */\n  this.apply = function (child, node, parent) {\n    //const parent = child.parent;\n    if (!parent) return;\n    const schema = node.parent; //node.parent.schema;\n    const metadata = child.mutation;\n    if (parent.id <= 0) {\n      metadata.tempkey = {};\n      metadata.tempkey[this.fk] = parent.id;\n    }\n    if (schema.identity) {\n      child[\'$\' + this.fk] = parent[this.pk];\n      //child.mutate(this.fk, parent[this.pk]);\n    } else {\n      const keys = this.pk.split(\',\');\n      let field;\n      for (let k = 0; k < keys.length; k++) {\n        field = keys[k];\n        child[\'$\' + field + schema.etype] = parent[field];\n        //child.mutate(field + schema.etype, parent[field]);\n      }\n    }\n\n    metadata.linked = true;\n  };\n  this.connected = function (obj) {\n    return obj.parent && obj[this.fk] === obj.parent[this.pk];\n  };\n}\nfunction TopLink(pk, fk, direction, association) {\n  GraphLink.call(this, pk, fk, direction, association);\n  this.apply = function (child, node, parent) {\n    //const parent = child.parent;\n    const metadata = child.mutation;\n    if (child.id < 1) {\n      metadata.tempkey = {};\n      metadata.tempkey[this.fk] = parent.id;\n    }\n    if (node.identity) {\n      parent[\'$\' + this.fk] = child[this.pk];\n      //parent.mutate(this.fk, child[this.pk]);\n    } else {\n      const keys = this.pk.split(\',\');\n      let field;\n      for (let k = 0; k < keys.length; k++) {\n        field = keys[k];\n        parent[\'$\' + field + node.etype] = child[field];\n        //parent.mutate(field + node.etype, child[field]);\n      }\n    }\n\n    metadata.linked = true;\n  };\n  this.connected = function (obj) {\n    return obj.parent && obj.parent[this.fk] === obj[this.pk];\n  };\n}\nfunction DoubleLink(pk, fk, direction, association) {\n  GraphLink.call(this, pk, fk, direction, association);\n  this.apply = function (child, node, parent) {\n    //const parent = child.parent;\n    const linked = {};\n    const mutation = {};\n    linked.tempkey = {};\n    if (parent.id < 1) linked.tempkey[this.pk] = parent.id;\n    mutation[this.pk] = parent.id;\n    if (child.id < 1) linked.tempkey[this.fk] = child.id;\n    mutation[this.fk] = child.id;\n    linked.mutated = mutation;\n    child.mutation.linked = linked;\n  };\n  this.connected = function (obj) {\n    const linked = obj.__mutation?.linked;\n    return linked && obj.parent && linked.mutated[this.pk] === obj.parent.id && linked.mutated[this.fk] === obj.id;\n  };\n}\n\n//# sourceURL=webpack://webground/./src/graph.js?')},"./src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $Array: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_11__.$Array),\n/* harmony export */   $Data: () => (/* reexport safe */ _data__WEBPACK_IMPORTED_MODULE_3__.$Data),\n/* harmony export */   $String: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_11__.$String),\n/* harmony export */   $Type: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_11__.$Type),\n/* harmony export */   Block: () => (/* reexport safe */ _code__WEBPACK_IMPORTED_MODULE_9__.Block),\n/* harmony export */   DataModel: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_1__.DataModel),\n/* harmony export */   DataObject: () => (/* reexport safe */ _data__WEBPACK_IMPORTED_MODULE_3__.DataObject),\n/* harmony export */   DataObserver: () => (/* reexport safe */ _observe__WEBPACK_IMPORTED_MODULE_8__.DataObserver),\n/* harmony export */   Link: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_6__.Link),\n/* harmony export */   MutableObject: () => (/* reexport safe */ _data__WEBPACK_IMPORTED_MODULE_3__.MutableObject),\n/* harmony export */   Observable: () => (/* reexport safe */ _observe__WEBPACK_IMPORTED_MODULE_8__.Observable),\n/* harmony export */   Shared: () => (/* reexport safe */ _binding__WEBPACK_IMPORTED_MODULE_10__.Shared),\n/* harmony export */   TypeSchema: () => (/* reexport safe */ _metadata__WEBPACK_IMPORTED_MODULE_7__.TypeSchema),\n/* harmony export */   assignIfNull: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_11__.assignIfNull),\n/* harmony export */   axiosChannel: () => (/* reexport safe */ _channels_AxiosChannel__WEBPACK_IMPORTED_MODULE_4__.axiosChannel),\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   char: () => (/* binding */ char),\n/* harmony export */   context: () => (/* reexport safe */ _context__WEBPACK_IMPORTED_MODULE_2__.context),\n/* harmony export */   core: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.core),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   deferredAction: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.deferredAction),\n/* harmony export */   donothing: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.donothing),\n/* harmony export */   double: () => (/* binding */ double),\n/* harmony export */   fetchChannel: () => (/* reexport safe */ _channels_FetchChannel__WEBPACK_IMPORTED_MODULE_5__.fetchChannel),\n/* harmony export */   float: () => (/* binding */ float),\n/* harmony export */   int: () => (/* binding */ int),\n/* harmony export */   isString: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_11__.isString),\n/* harmony export */   localStore: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.localStore),\n/* harmony export */   long: () => (/* binding */ long),\n/* harmony export */   money: () => (/* binding */ money),\n/* harmony export */   sessionStore: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.sessionStore),\n/* harmony export */   small: () => (/* binding */ small),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   waitAction: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.waitAction)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ "./src/model.js");\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context */ "./src/context.js");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./src/data.js");\n/* harmony import */ var _channels_AxiosChannel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./channels/AxiosChannel */ "./src/channels/AxiosChannel.js");\n/* harmony import */ var _channels_FetchChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./channels/FetchChannel */ "./src/channels/FetchChannel.js");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graph */ "./src/graph.js");\n/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./metadata */ "./src/metadata.js");\n/* harmony import */ var _observe__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./observe */ "./src/observe.js");\n/* harmony import */ var _code__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./code */ "./src/code.js");\n/* harmony import */ var _binding__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./binding */ "./src/binding.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\n\n\n\n\n\n\n\n\n\n\n\nconst bool = 0;\nconst small = 1;\nconst string = 2;\nconst decimal = 3;\nconst double = 4;\nconst float = 5;\nconst int = 6;\nconst long = 7;\nconst date = 8;\nconst money = 3;\nconst char = 2;\n\n//# sourceURL=webpack://webground/./src/index.js?')},"./src/metadata.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypeSchema: () => (/* binding */ TypeSchema)\n/* harmony export */ });\nvar TypeSchema = {};\n\n//# sourceURL=webpack://webground/./src/metadata.js?")},"./src/model.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataModel: () => (/* binding */ DataModel)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ "./src/data.js");\n/* harmony import */ var _observe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observe */ "./src/observe.js");\n\n\n\nfunction DataModel() {\n  this.source = null;\n  //this.state = null;\n}\n\n_core__WEBPACK_IMPORTED_MODULE_0__.core.prototypeOf(_observe__WEBPACK_IMPORTED_MODULE_2__.Observable, DataModel, {\n  defaultOption: {\n    apiUrl: "api/"\n  },\n  $implement: [Symbol.for(\'es.isync\')],\n  etype: null,\n  ExecuteApi: function (url, params, option) {\n    //this.state = {url, params, option};\n    return this.api.call(url, params, {\n      ...this.defaultOption,\n      ...option\n    });\n  },\n  ExecuteScalar: function (url, params, option) {\n    return this.api.call(url, params, {\n      ...this.defaultOption,\n      ...option\n    }).then(result => {\n      console.log("API SERVICE REQUEST RESULT" + result.data, result);\n      return this.setSource(result.data);\n    }, er => {\n      console.log("ERROR API SERVICE REQUEST", er);\n      throw er;\n    });\n  },\n  ExecuteQuery: function (url, params, option) {\n    return this.api.call(url, params, {\n      ...this.defaultOption,\n      ...option\n    }).then(result => {\n      console.log("API SERVICE REQUEST RESULT" + result.data, result);\n      return this.setSource(result.data); //: [result.data] Array.isArray(result.data) ?  : null\n    }, er => {\n      console.log("ERROR API SERVICE REQUEST", er);\n      throw er;\n    });\n  },\n  collection: function (predicate) {\n    return this.ExecuteQuery("collection", {\n      predicate: predicate,\n      itype: this.etype\n    });\n  },\n  item: function (id) {\n    return this.ExecuteQuery("item", {\n      id: id,\n      itype: this.etype\n    });\n  },\n  ServiceApi: function (name, data, option) {\n    return this.ExecuteApi(name, data, {\n      apiUrl: "service/app/",\n      ...option\n    });\n  },\n  delete: function (data, option) {\n    const defaultOpt = {\n      delOp: "api/jdelete",\n      excludeParams: true\n    };\n    Object.assign(defaultOpt, option);\n    if (!Array.isArray(data)) data = [data];\n    const mutation = [];\n    data.forEach(function (item) {\n      //item.mutation.crud = 3;\n      if (!item) return;\n      mutation.push(isNaN(item) ? item.mutation : {\n        id: item\n      });\n    });\n    return this.api.call(defaultOpt.delOp, {\n      etype: this.etype,\n      Mutation: mutation\n    }, defaultOpt);\n  },\n  setSource: function (source) {\n    this.source = _data__WEBPACK_IMPORTED_MODULE_1__.$Data.cast(source, this.etype);\n    this.emit("SOURCE_CHANGED", this.source);\n    return this.source;\n  },\n  createSource: function (key, call, initialData, predicate) {\n    const api = call ? call(this) : this.ExecuteApi("collection", {\n      predicate,\n      itype: this.etype\n    });\n    return api.then(result => {\n      _core__WEBPACK_IMPORTED_MODULE_0__.core.source.set(key, result.data || initialData);\n    });\n  },\n  sync: function (item) {\n    this.source && this.source.sync(item) && this.refresh();\n  },\n  refresh: function () {\n    this.emit("SOURCE_CHANGED", Array.isArray(this.source) ? [...this.source] : _data__WEBPACK_IMPORTED_MODULE_1__.$Data.clone(this.source)); //$Data.cast(...this.source, this.etype));\n  },\n\n  reload: function () {},\n  //TODO: Creare in automatico in form se è null, oggetto vuoto or not casted\n  newInstance: function (initialValues) {\n    return _data__WEBPACK_IMPORTED_MODULE_1__.$Data.cast(initialValues || {}, this.etype);\n  }\n});\n_core__WEBPACK_IMPORTED_MODULE_0__.core.inject(DataModel, "IApi,IContext");\n\n//# sourceURL=webpack://webground/./src/model.js?')},"./src/observe.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataObserver: () => (/* binding */ DataObserver),\n/* harmony export */   Observable: () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code */ "./src/code.js");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./src/core.js");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\n\n\nfunction Observable() {}\nObservable.prototype = {\n  $$type: Observable,\n  base: function () {\n    //For future implementation\n  },\n  events: null,\n  listen_old: function (event, observer) {\n    observer = observer || this;\n    const list = this.listeners.get(event);\n    if (!list) {\n      list = new Set();\n      this.listeners.set(event, list);\n    }\n    const task = observer.createTask(event, {\n      parent: list\n    });\n    list.add(task);\n    return task;\n  },\n  listen: function (event, observer) {\n    observer = observer || this;\n    const proto = Object.getPrototypeOf(this); //this.$$type.prototype;\n\n    if (!proto.events?.hasOwnProperty(event)) proto.events = {\n      ...proto.events,\n      [event]: new ObserverMap()\n    };\n    proto.events[event].push(this, observer);\n    return observer;\n  },\n  listenGlobal: function (event, observer) {\n    return _core__WEBPACK_IMPORTED_MODULE_1__.core.context.listen(event, observer || this);\n  },\n  listenLocal: function (event, observer) {\n    return this.context.listen(event, observer || this);\n  },\n  //CHECK CASE of emitter same type of observer, if emit discendant can call twice task associated with observer\n  observeOld: function (event, observable) {\n    return (observable || this).listen(event, this.createTask());\n  },\n  observe: function (event, observer) {\n    const task = observer ? observer.createTask() : new _code__WEBPACK_IMPORTED_MODULE_0__.Task();\n    this.listen(event, task);\n    return task;\n  },\n  observeGlobal: function (event) {\n    return _core__WEBPACK_IMPORTED_MODULE_1__.core.context.observe(event, this);\n  },\n  observeLocal: function (event) {\n    return this.context.observe(event, this);\n  },\n  override: function (event, observable, predicate) {\n    this.observe(event, observable).override(predicate);\n  },\n  unobserve: function (predicate) {\n    predicate = predicate || (() => true);\n    this.metadata.get("disposable", Array).forEach(el => el instanceof Observer && predicate(el) && el.dispose());\n  },\n  emit: function (event, data, target, name) {\n    target = target || this;\n    let noglobal = target !== this.context;\n    const token = {\n      event,\n      data,\n      target,\n      name,\n      emitter: this,\n      type: this.$$type,\n      context: this.context\n    };\n    const flow = new _code__WEBPACK_IMPORTED_MODULE_0__.Flow();\n    if (target.intent && target.intent[event]) {\n      flow.task(target.intent[event].bind(target), {\n        currentTarget: target,\n        current: this\n      });\n    }\n    if (this !== target && this.intent && this.intent[event]) {\n      flow.task(this.intent[event].bind(this), {\n        currentTarget: target,\n        current: this\n      });\n    }\n    const constructor = function (collection, currentTarget, observable) {\n      collection && collection.forEach(task => {\n        if (task instanceof Observable) task = task.createTask();else if (!(task instanceof _code__WEBPACK_IMPORTED_MODULE_0__.Task)) task = new _code__WEBPACK_IMPORTED_MODULE_0__.Task(task);\n        if (task.executable(token, {\n          currentTarget,\n          current: observable\n        })) {\n          task.policy ? task.policy(flow, token) : flow.import(task);\n        }\n      });\n    };\n    const build = (current, currentTarget) => {\n      while (current) {\n        if (current instanceof Observable) {\n          currentTarget = currentTarget?.parent;\n          constructor(current.getListeners(event), currentTarget, current);\n          constructor(current.getListeners(\'*\'), currentTarget, current);\n        }\n        current = current.parent;\n        if (current === this.context) noglobal = false;\n      }\n    };\n    build(this, target);\n    noglobal && build(this.context); // CTX EMIT / GLOBAL EMIT\n\n    return flow.execute(token);\n  },\n  execute: async function (evt, token) {\n    return this.intent?.hasOwnProperty(evt) && (await this.intent[evt].bind(this)(token));\n  },\n  createTask: function (data) {\n    return new _code__WEBPACK_IMPORTED_MODULE_0__.Task(token => this.execute(token.event, token), {\n      ...data,\n      owner: this\n    });\n  },\n  executeIntent(event, data, token) {\n    return this.execute(event, token || {\n      event,\n      data,\n      target: this,\n      emitter: this,\n      type: this.$$type,\n      context: this.context,\n      token: {}\n    });\n  },\n  createIntent: function (name, data) {\n    //createIntent\n    return this.intent?.hasOwnProperty(name) ? this.createTask(data).make(this.intent[name].bind(this)) : null; //oppure donothing task !?!?!?\n  },\n\n  attach: function (intent, data, callback) {\n    const block = this.task(intent, data);\n    const flow = this.context.flow;\n    callback ? callback(flow)(block) : flow.task(block);\n  },\n  getListeners: function (event) {\n    return this.events ? this.events[event]?.get(this) : null;\n  },\n  disposable: function (disposable) {\n    this.metadata.get("disposable", Array).push(disposable);\n    return disposable;\n  },\n  metadata: function () {\n    return _core__WEBPACK_IMPORTED_MODULE_1__.core.metadata(this);\n  },\n  dispose: function () {\n    this.metadata.get("disposable", Array).forEach(el => el.dispose());\n  }\n};\n_core__WEBPACK_IMPORTED_MODULE_1__.core.inject(Observable, "IContext");\nfunction ObserverMap() {\n  this.map = new WeakMap();\n  //this.cache = new WeakMap();\n}\n\n_core__WEBPACK_IMPORTED_MODULE_1__.core.prototypeOf(_code__WEBPACK_IMPORTED_MODULE_0__.ITask, ObserverMap, {\n  push: function (target, observer) {\n    if (!this.map.has(target)) this.map.set(target, observer);else {\n      this.map.set(target, [].concat(this.map.get(target), observer));\n    }\n  },\n  get: function (target) {\n    let obs = this.map.get(target);\n    if (!Array.isArray(obs)) obs = [obs];\n    return obs;\n  }\n});\n\n/*if (!this.map.has(target))\r\n            this.map.set(traget, observer);\r\n        else if (!this.cache.has(target))\r\n            this.cache.set(traget, observer);\r\n        else{\r\n            this.cache.set(traget, [].concat(this.cache.get(traget), observer));\r\n        }*/\n\nfunction DataObserver(fields, required) {\n  this.fields = fields;\n  this.required = required;\n}\nDataObserver.prototype = {\n  hasValue: function () {\n    this.required = true;\n    return this;\n  },\n  execute: function (_ref) {\n    let {\n      data\n    } = _ref;\n    if (this.fields) {\n      if (this.required) {\n        const fields = this.fields.split(",");\n        for (let k = 0; k < fields.length; k++) {\n          if (!data.values[fields[k]]) return false; //Se 0 (zero) rnde false...\n        }\n      }\n\n      return ("," + this.fields.trim().replaceAll(" ", "") + ",").indexOf("," + data.field + ",") !== -1;\n    }\n    return false;\n  }\n};\n\n//observe: null=> actual node, \'*\' => global (graph observer), path => node find by path\n\n//# sourceURL=webpack://webground/./src/observe.js?')},"./src/space.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Space: () => (/* binding */ Space)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/utils.js");\n\nfunction Space() {\n  this.store = new Map();\n}\n\n//const shared = this.shared.get($Type.of(target)); \n\nSpace.prototype = {\n  share: function (obj) {\n    const type = _utils__WEBPACK_IMPORTED_MODULE_0__.$Type.of(obj);\n    this.store.has(type) ? this.store.get(type).add(obj) : this.store.set(type, new Set().add(obj));\n    //TODO: --\x3eRISE SEARCH TO ROOT\n  },\n\n  unshare: function (obj) {\n    const type = _utils__WEBPACK_IMPORTED_MODULE_0__.$Type.of(obj);\n    this.store.has(type) && this.store.get(type).delete(obj);\n  }\n};\n\n//# sourceURL=webpack://webground/./src/space.js?')},"./src/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $Array: () => (/* binding */ $Array),\n/* harmony export */   $String: () => (/* binding */ $String),\n/* harmony export */   $Type: () => (/* binding */ $Type),\n/* harmony export */   ArrayMoveElementAt: () => (/* binding */ ArrayMoveElementAt),\n/* harmony export */   ArrayOrderElementAt: () => (/* binding */ ArrayOrderElementAt),\n/* harmony export */   DateEnum: () => (/* binding */ DateEnum),\n/* harmony export */   DateInterval: () => (/* binding */ DateInterval),\n/* harmony export */   assignIfNull: () => (/* binding */ assignIfNull),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   randomIntFromInterval: () => (/* binding */ randomIntFromInterval),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   todecimal: () => (/* binding */ todecimal)\n/* harmony export */ });\nconst $Array = {\n  remove: (array, p) => {\n    const index = array.findIndex(p);\n    if (index > -1) array.splice(index, 1);\n    return index;\n  },\n  removeItem: (array, p) => {\n    const index = array.findIndex(i => i === p);\n    if (index > -1) array.splice(index, 1);\n    return index;\n  },\n  removeAt: (array, index) => {\n    index > -1 && index < array.length && array.splice(index, 1);\n  }\n};\nconst $String = {\n  capitalize: word => word.charAt(0).toUpperCase() + word.slice(1),\n  is: value => typeof value === 'string'\n};\nconst $Type = {\n  isObject: obj => obj && typeof obj === 'object' && obj.constructor === Object,\n  // typeof(obj) === 'function', Object.prototype.toString.call(x) == '[object Function]', x instanceof Function\n  isFunction: obj => obj && typeof obj === 'function',\n  // && Object.prototype.toString.call(obj) == '[object Function]', \n\n  isString: value => typeof value === 'string',\n  of: obj => Object.getPrototypeOf(obj).constructor,\n  nameOf: obj => undefined.of(obj).name\n};\nfunction assignIfNull(target, source) {\n  for (const key in source) {\n    const field = target[key];\n    if (field === undefined || field === null || Array.isArray(field) && field.length === 0) target[key] = source[key];\n  }\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => setTimeout(resolve, timeout));\n}\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getParamNames(func) {\n  var fnStr = func.toString().replace(STRIP_COMMENTS, '');\n  var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n  if (result === null) result = [];\n  return result;\n}\nfunction randomIntFromInterval(min, max) {\n  // min and max included \n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\nconst DateEnum = {\n  day: 'Day',\n  week: 'WorkWeek',\n  month: 'Month'\n};\nfunction DateInterval(format, date) {\n  format = format || DateEnum.day;\n  date = date || new Date();\n  console.log(\"DateInterval\", format, date);\n  date.setHours(0, 0, 0, 0);\n  let te;\n  if (format === DateEnum.day) {\n    te = new Date(date);\n    te.setDate(date.getDate() + 1);\n    return {\n      ts: date.toISOString().substring(0, 19),\n      te: te.toISOString().substring(0, 19)\n    };\n  } else if (format === DateEnum.week) {\n    let day = date.getDay() - 1;\n    if (day === -1) day = 6;\n    date.setDate(date.getDate() - day);\n    te = new Date(date);\n    te.setDate(date.getDate() + 6);\n    return {\n      ts: date.toISOString().substring(0, 19),\n      te: te.toISOString().substring(0, 19)\n    };\n  } else if (format === DateEnum.month) {\n    date.setDate(1);\n    let day = date.getDay() - 1;\n    if (day === -1) day = 6;\n    date.setDate(date.getDate() - day);\n    te = new Date(date);\n    te.setDate(date.getDate() + 35);\n    return {\n      ts: date.toISOString().substring(0, 19),\n      te: te.toISOString().substring(0, 19)\n    };\n  }\n}\nfunction isString(s) {\n  return typeof s === 'string';\n}\nfunction todecimal(value) {\n  if (!value) return 0;\n  var result = 0;\n  if (value.indexOf(\"€\") == -1) result = Number(value.replace(/\\,/g, \".\"));else if (value[0] == \"€\") result = Number(value.substr(2, value.length - 2).replace(/\\,/g, \".\"));else result = Number(value.substr(0, value.length - 2).replace(/\\,/g, \".\"));\n  return result;\n}\nfunction ArrayMoveElementAt(arr, fromIndex, toIndex) {\n  const element = arr.splice(fromIndex, 1)[0];\n  console.log(element);\n  arr.splice(toIndex, 0, element);\n}\nfunction ArrayOrderElementAt(arr, fromIndex, toIndex, field) {\n  field = field || \"iorder\";\n  ArrayMoveElementAt(arr, fromIndex, toIndex);\n  let s, e;\n  if (fromIndex < toIndex) {\n    s = fromIndex;\n    e = toIndex + 1;\n  } else {\n    s = toIndex;\n    e = fromIndex + 1;\n  }\n  for (let k = s; k < e; k++) {\n    arr[k][field] = k + 1;\n  }\n}\n\n//# sourceURL=webpack://webground/./src/utils.js?")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__})()));